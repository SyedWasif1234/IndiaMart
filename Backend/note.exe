🔍 Description

Create a backend API for an IndiaMART-like B2B platform, where users can register as buyers or sellers. Sellers can list products, and buyers can search and send inquiries. Admins can manage everything. This project helps you learn authentication, RBAC (Role-Based Access Control), product listings, and real-world marketplace workflows using PHP and MySQL.

---

 🎯 End Goal

* Modular PHP backend (MVC-like structure)
* MySQL database
* JWT-based authentication (or PHP session-based auth for simplicity)
* Role-based route protection (buyer, seller, admin)
* Clean API routes for managing users, products, and orders
* Admin dashboard APIs
* Postman collection to test each feature


 👥 Roles Involved

* Buyer: Browse products, search, send inquiries
* Seller: Add/edit/delete products, respond to inquiries
* Admin: Manage users, moderate products, view analytics



 📊 Tables to be Created

users          -- id, name, email, password, role (buyer/seller/admin)
products       -- id, seller_id, title, description, price, category_id, image
categories     -- id, name
inquiries      -- id, product_id, buyer_id, message, status
orders         -- optional (if you want to support order tracking)
messages       -- optional for chat


 🧾 API Routes to Build

 🔐 Auth: ✅(DONE)

* POST /auth/register → Register as buyer or seller
* POST /auth/login → Login, return token/session
* GET /auth/me → Get current user info




 🛒 Product Management:

* GET /products → List all products (public)
* GET /products/:id → Product detail (public)
* POST /products → Seller only
* PUT /products/:id → Seller only (own products)
* DELETE /products/:id → Seller only or Admin

📨 Inquiry System:

* POST /inquiries → Buyer sends inquiry to seller
* GET /inquiries → Seller/Admin views inquiries
* PUT /inquiries/:id/respond → Seller responds

    Sellers only get inquiries related to their own products.
    Admins can still view all inquiries.
    Buyers cannot access this route at all.

 🧑‍💼 Admin Panel:

* GET /admin/users → List all users
* DELETE /admin/users/:id → Delete user
* PUT /admin/users/:id/role → Change user role
* GET /admin/products → Moderate product listings

 🧠 Bonus Features (Optional)

* 🔔 Notifications for new inquiries
* 📅 Product expiry or promotion timer
* 📂 CSV product export (admin)
* 🛒 Add cart + order flow
* 📈 Admin dashboard analytics (products per seller, inquiry stats)



 ✅ Deliverables Checklist

* [x] Auth system (Login/Register)
* [x] Role-based route access
* [x] Product listing CRUD
* [x] Inquiry system between buyer and seller
* [x] Admin routes (manage users/products)
* [x] Postman collection for API testing
* [x] Clean MVC-style folder structure
* [x] MySQL schema with proper relationships

USE MEMO()

    Imagine this:
    You're running a restaurant.
    You make tea for customers.
    Making tea takes 10 minutes.

    Now, a customer comes and says:

    "Give me 1 cup of tea."

    You go to the kitchen and make it from scratch.
    ✅ That’s fine.

    But then 2 seconds later, the same customer says:

    "Can I get the same tea again?"

    You say:

    "Oh! I’ll make it again from scratch."

    That’s a waste of time ⏳, right?

    So what’s smarter?
    You say:

    "I already made that tea. I’ll keep it ready in a flask, so if the same order comes again, I’ll just serve it instantly!"

    ✅ That’s what useMemo does!

    In React:
    
        Your app keeps showing things on the screen (like name, number, product list).
        React re-renders (refreshes) the screen every time something changes.
        But sometimes you’re recalculating something heavy, like:
        A big math formula
        Filtering 1000 products
        Sorting large lists
        Even if nothing important changed, React still runs that logic again — which is slow.

    useMemo says:

        “Don’t do the work again unless it’s really needed.”
        It remembers the result of that big calculation, like tea in a flask.
border-r
border-l
border-t
border-d

JSON.stringify(value, replacer, space)

flex: makes the buttons sit horizontally.
flex-1: makes each child take equal width.
gap-2: adds space between them.
w-full inside the button tag inside Link ensures full usage of the flexed width.

//  i did this in adminside bar section because niche gap arha tha
- <div className="  w-60 bg-white border-r h-screen space-y-4">
+ <div className="w-60 bg-white border-r flex-shrink-0">
That’s it—because:

The outer wrapper in AdminLayout already has
flex min-h-screen, so it always reaches the bottom of the viewport (and
beyond when your page is taller).

With flex-shrink-0 (or even no height class at all) the <aside> will
simply grow to the same height as the wrapper, eliminating the gap.
//